package cmd

import (
	"path/filepath"
	"reflect"
	"testing"

  "strings"
)

func TestCompile(t *testing.T) {
  files := []string{"../testdata/simple/header.md", "../testdata/simple/list.md"}
	notice := "<strong>Autogenerated</strong>"
  compiled := string(Compile(files, notice))

  headerIndex := strings.Index(compiled, "h1")
  listIndex := strings.Index(compiled, "ul")
	noticeIndex := strings.Index(compiled, notice)

	if noticeIndex == -1 {
		t.Errorf("expected document to contain notice, got %s" , compiled)
	}

  if headerIndex == -1 || listIndex == -1 || headerIndex > listIndex {
    t.Errorf("expeced header to be before list. header %d list %d (%s)", headerIndex, listIndex, compiled)
  }
}

func TestResolve(t *testing.T) {
	testdataPath := func(file string) string {
		file = filepath.Join("..", "testdata", file)
		abs, _ := filepath.Abs(file)
		return abs
	}

	t.Run("Expands glob files", func(t *testing.T) {
		files := []string{"../testdata/wiki/*.md"}

		got := Resolve(files)
		want := []string{testdataPath("wiki/a.md"), testdataPath("wiki/b.md")}

		if !reflect.DeepEqual(want, got) {
			t.Errorf("expeced %+v got %+v", want, got)
		}
	})

	t.Run("Uniquely appends files", func(t *testing.T) {
		files := []string{"../testdata/wiki/b.md", "../testdata/wiki/*.md"}
    got := Resolve(files)
		want := []string{testdataPath("wiki/b.md"), testdataPath("wiki/a.md")}

		if !reflect.DeepEqual(want, got) {
			t.Errorf("expeced %+v got %+v", want, got)
		}
	})
}
